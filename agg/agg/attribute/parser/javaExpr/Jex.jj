/* Generated By:JJTree: Do not edit this line. Jex.jj */
options {
ERROR_REPORTING=true;
STATIC=true;
USER_CHAR_STREAM=false;
OTHER_AMBIGUITY_CHECK=1;
BUILD_TOKEN_MANAGER=true;
DEBUG_TOKEN_MANAGER=false;
DEBUG_LOOKAHEAD=false;
USER_TOKEN_MANAGER=false;
LOOKAHEAD=1;
IGNORE_CASE=false;
FORCE_LA_CHECK=false;
SANITY_CHECK=true;
JAVA_UNICODE_ESCAPE=false;
CHOICE_AMBIGUITY_CHECK=2;
BUILD_PARSER=true;
DEBUG_PARSER=false;
COMMON_TOKEN_ACTION=false;
UNICODE_INPUT=false;
}

PARSER_BEGIN(JexParser)
public class JexParser{
  protected static JJTJexParserState jjtree = new JJTJexParserState();
}
final class JJTJexParserState {
  /* JJTree builds the AST bottom up.  It constructs nodes and places
     them on a stack.  When all the children have been assembled, they
     are added to their parent and popped from the stack. */
  private JJTJexParserNodeStack nodes;

  /* The current node is kept on the top of this stack so that user
     actions can always refer to it. */
  private java.util.Stack current_nodes;

  /* We keep track of whether a node was actually created.  Definite
     and indefinite nodes always are, but GT nodes are only closed and
     pushed on the stack if their conditions are true. */
  private boolean node_created;

  JJTJexParserState() {
    nodes = new JJTJexParserNodeStack();
    current_nodes = new java.util.Stack();
  }

  /* Determine whether the current node was actually closed and pushed */
  boolean nodeCreated() {
    return node_created;
  }

  /* Called when the current node has been completely finished with.
     Makes a new node the current node. */
  void updateCurrentNode(int n) {
    for (int i = 0; i < n; ++i) {
      current_nodes.pop();
    }
  }

  /* Call this to reinitialize the node stack.  */
  void reset() {
    nodes.empty();
    current_nodes = new java.util.Stack();
  }

  /* Return the root node of the AST. */
  Node rootNode() {
    return nodes.elementAt(0);
  }

  /* Return the most recently constructed node. */
  Node currentNode() {
    return (Node)current_nodes.peek();
  }

  /* Push a node on to the stack. */
  void pushNode(Node n) {
    nodes.push(n);
  }

  /* Return the node on the top of the stack, and remove it from the
     stack.  */
  Node popNode() {
    return nodes.pop();
  }

  /* Return the node currently on the top of the stack. */
  Node peekNode() {
    return nodes.peek();
  }

  /* An indefinite node has an unspecified number of children.  When
     it is closed it collects up all nodes that have been pushed since
     it was begun and becomes their parent, and then it is pushed on
     to the stack. */

  void openIndefiniteNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeIndefiniteNode() {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTJexParserNodeEnum e = nodes.elementsSinceLastMark();
	 e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popToLastMark();
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A definite node is constructed from a fixed number of children.
     That number of nodes are popped from the stack and made the
     children of the definite node.  Then the definite node is pushed
     on to the stack. */

  void openDefiniteNode(Node n) {
    current_nodes.push(n);
  }

  void closeDefiniteNode(int num) {
    Node n = currentNode();
    n.jjtOpen();
    for (JJTJexParserNodeEnum e = nodes.elementsTop(num); e.hasMoreElements(); ) {
      Node c = (Node)e.nextElement();
      c.jjtSetParent(n);
      n.jjtAddChild(c);
    }
    nodes.popTop(num);
    n.jjtClose();
    nodes.push(n);
    node_created = true;
  }

  /* A GT (Greater Than) node is constructed if more than the
     specified number of nodes have been pushed since it was begun.
     All those nodes are made children of the the GT node, which is
     then pushed on to the stack.  If fewer have been pushed the node
     is not constructed and they are left on the stack. */

  void openGTNode(Node n) {
    current_nodes.push(n);
    nodes.mark();
  }

  void closeGTNode(int num) {
    if (nodes.numElementsSinceLastMark() > num) {
      closeIndefiniteNode();
    } else {
      nodes.removeLastMark();
      node_created = false;
    }
  }
}

final class JJTJexParserNodeStack {
  private Node[] nodeStack;
  private int[] markStack;
  private int nodeSP;
  private int markSP;

  JJTJexParserNodeStack() {
    nodeStack = new Node[500];
    markStack = new int[500];
    nodeSP = 0;
    markSP = 0;
  }

  void empty() {
    if (nodeSP > 0) {
      while (--nodeSP >= 0) {
	nodeStack[nodeSP] = null;
      }
    }
    nodeSP = 0;
    markSP = 0;
  }

  Node elementAt(int i) {
    return nodeStack[i];
  }

  Node elementFromTop(int i) {
    return nodeStack[nodeSP - i - 1];
  }

  void push(Node n) {
    if (nodeSP == nodeStack.length) {
      Node[] ns = new Node[nodeStack.length * 2];
      System.arraycopy(nodeStack, 0, ns, 0, nodeStack.length);
      nodeStack = ns;
    }
    nodeStack[nodeSP++] = n;
  }

  Node pop() {
    Node n = nodeStack[--nodeSP];
    nodeStack[nodeSP] = null;
    return n;
  }

  Node peek() {
    return nodeStack[nodeSP - 1];
  }

  void mark() {
    if (markSP == markStack.length) {
      int[] ms = new int[markStack.length * 2];
      System.arraycopy(markStack, 0, ms, 0, markStack.length);
      markStack = ms;
    }
    markStack[markSP++] = nodeSP;
  }

  void removeLastMark() {
    --markSP;
  }

  int numElementsSinceLastMark() {
    return nodeSP - markStack[markSP - 1];
  }

  JJTJexParserNodeEnum elementsSinceLastMark() {
    return new JJTJexParserNodeEnum(nodeStack, nodeSP, markStack[markSP - 1]);
  }

  void popToLastMark() {
    --markSP;
    while (nodeSP > markStack[markSP]) {
      nodeStack[--nodeSP] = null;
    }
  }

  JJTJexParserNodeEnum elementsTop(int n) {
    return new JJTJexParserNodeEnum(nodeStack, nodeSP, nodeSP - n);
  }

  void popTop(int n) {
    for (int i = 0; i < n; ++i) {
      nodeStack[--nodeSP] = null;
    }
  }
}

final class JJTJexParserNodeEnum implements java.util.Enumeration {
  private Node[] nodes;
  private int topSP, index;

  JJTJexParserNodeEnum(Node[] s, int top, int start) {
    nodes = s;
    topSP = top;
    index = start;
  }

  public boolean hasMoreElements() {
    return index < topSP;
  }

  public Object nextElement() {
    return nodes[index++];
  }
}

PARSER_END(JexParser)


<DEFAULT> SKIP : {
" "
| "\t"
| "\n"
| "\r"
| "\f"
}


<DEFAULT> TOKEN : {
<INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])?  | <HEX_LITERAL> (["l","L"])?  | <OCTAL_LITERAL> (["l","L"])? >
| <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| <#OCTAL_LITERAL: "0" (["0"-"7"])* >
| <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?  | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?  | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?  | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| <CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) ) "\'" >
| <STRING_LITERAL: "\"" (~["\"","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] ) )* "\"" >
}


<DEFAULT> TOKEN : {
<LPAREN: "(">
| <RPAREN: ")">
| <LBRACE: "{">
| <RBRACE: "}">
| <LBRACKET: "[">
| <RBRACKET: "]">
| <SEMICOLON: ";">
| <COMMA: ",">
| <DOT: ".">
| <DOLLAR: "$">
}

/*
 * Expression syntax follows.
 */

void CompilationUnit() /*#void*/ : {}
{
 Expression() <EOF>
}

void Expression() /*#Expression*/ : {}
{
{
jjtree.openIndefiniteNode(ASTExpression.jjtCreate("Expression"));
}
 ConditionalExpression(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void ConditionalExpression() /*#void*/ : {}
{
 ConditionalOrExpression() (  "?" Expression() ":" {
jjtree.openDefiniteNode(ASTCondExpr.jjtCreate("CondExpr"));
}
ConditionalExpression(){
jjtree.closeDefiniteNode(3);
jjtree.updateCurrentNode(1);
}
 /*#CondExpr(3)*/ )?
}

void ConditionalOrExpression() /*#void*/ : {}
{
 ConditionalAndExpression() (  "||" {
jjtree.openDefiniteNode(ASTOrNode.jjtCreate("OrNode"));
}
ConditionalAndExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#OrNode(2)*/ )*
}

void ConditionalAndExpression() /*#void*/ : {}
{
 InclusiveOrExpression() (  "&&" {
jjtree.openDefiniteNode(ASTAndNode.jjtCreate("AndNode"));
}
InclusiveOrExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#AndNode(2)*/ )*
}

void InclusiveOrExpression() /*#void*/ : {}
{
 ExclusiveOrExpression() (  "|" {
jjtree.openDefiniteNode(ASTBitwiseOrNode.jjtCreate("BitwiseOrNode"));
}
ExclusiveOrExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#BitwiseOrNode(2)*/ )*
}

void ExclusiveOrExpression() /*#void*/ : {}
{
 AndExpression() (  "^" {
jjtree.openDefiniteNode(ASTBitwiseXorNode.jjtCreate("BitwiseXorNode"));
}
AndExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#BitwiseXorNode(2)*/ )*
}

void AndExpression() /*#void*/ : {}
{
 EqualityExpression() (  "&" {
jjtree.openDefiniteNode(ASTBitwiseAndNode.jjtCreate("BitwiseAndNode"));
}
EqualityExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#BitwiseAndNode(2)*/ )*
}

void EqualityExpression() /*#void*/ : {}
{
 RelationalExpression() (  "==" {
jjtree.openDefiniteNode(ASTEQNode.jjtCreate("EQNode"));
}
RelationalExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#EQNode(2)*/ |  "!=" {
jjtree.openDefiniteNode(ASTNENode.jjtCreate("NENode"));
}
RelationalExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#NENode(2)*/  )*
}

void RelationalExpression() /*#void*/ : {}
{
 AdditiveExpression() (  "<" {
jjtree.openDefiniteNode(ASTLTNode.jjtCreate("LTNode"));
}
AdditiveExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#LTNode(2)*/ |  ">" {
jjtree.openDefiniteNode(ASTGTNode.jjtCreate("GTNode"));
}
AdditiveExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#GTNode(2)*/ |  "<=" {
jjtree.openDefiniteNode(ASTLENode.jjtCreate("LENode"));
}
AdditiveExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#LENode(2)*/ |  ">=" {
jjtree.openDefiniteNode(ASTGENode.jjtCreate("GENode"));
}
AdditiveExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#GENode(2)*/  )*
}

void AdditiveExpression() /*#void*/ : {}
{
 MultiplicativeExpression() (  "+" {
jjtree.openDefiniteNode(ASTAddNode.jjtCreate("AddNode"));
}
MultiplicativeExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#AddNode(2)*/ |  "-" {
jjtree.openDefiniteNode(ASTSubtractNode.jjtCreate("SubtractNode"));
}
MultiplicativeExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#SubtractNode(2)*/  )*
}

void MultiplicativeExpression() /*#void*/ : {}
{
 UnaryExpression() (  "*" {
jjtree.openDefiniteNode(ASTMulNode.jjtCreate("MulNode"));
}
UnaryExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#MulNode(2)*/ |  "/" {
jjtree.openDefiniteNode(ASTDivNode.jjtCreate("DivNode"));
}
UnaryExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#DivNode(2)*/ |  "%" {
jjtree.openDefiniteNode(ASTModNode.jjtCreate("ModNode"));
}
UnaryExpression(){
jjtree.closeDefiniteNode(2);
jjtree.updateCurrentNode(1);
}
 /*#ModNode(2)*/  )*
}

void UnaryExpression() /*#void*/ : {}
{
 "-" {
jjtree.openDefiniteNode(ASTNegNode.jjtCreate("NegNode"));
}
UnaryExpression(){
jjtree.closeDefiniteNode(1);
jjtree.updateCurrentNode(1);
}
 /*#NegNode(1)*/
|  "+" UnaryExpression()
|  UnsignedUnaryExpression()

}

void UnsignedUnaryExpression() /*#void*/ : {}
{
 "~" {
jjtree.openDefiniteNode(ASTBitwiseComplNode.jjtCreate("BitwiseComplNode"));
}
UnaryExpression(){
jjtree.closeDefiniteNode(1);
jjtree.updateCurrentNode(1);
}
 /*#BitwiseComplNode(1)*/
|  "!" {
jjtree.openDefiniteNode(ASTNotNode.jjtCreate("NotNode"));
}
UnaryExpression(){
jjtree.closeDefiniteNode(1);
jjtree.updateCurrentNode(1);
}
 /*#NotNode(1)*/
|  PrimaryExpression()

}

void PrimaryExpression() /*#void*/ : {}
{
LOOKAHEAD(2147483647,  "new" FullClassName() "[") ArrayAllocation()
|  ( ( {
jjtree.openIndefiniteNode(ASTPrimaryExpression.jjtCreate("PrimaryExpression"));
}
 PrimaryPrefix() (  PrimarySuffix() )*{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 ) /*#PrimaryExpression*/ )

}

void PrimaryPrefix() /*#void*/ : {}
{
 Literal()
|  Id()
|  "$" ClassName() "$"
|  "(" Expression() ")"
|  AllocationExpression()

}

void PrimarySuffix() /*#void*/ : {}
{
 ArrayIndex()
|  Member()
|  Action()

}

void ArrayIndex() /*#ArrayIndex*/ : {}
{
{
jjtree.openIndefiniteNode(ASTArrayIndex.jjtCreate("ArrayIndex"));
}
 "[" Expression() "]"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void Action() /*#Action*/ : {}
{
{
jjtree.openIndefiniteNode(ASTAction.jjtCreate("Action"));
}
 ";" MemberName() ArgumentList(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void Member() /*#void*/ : {}
{
 "." ( LOOKAHEAD(2147483647,  MemberName() "(") ( ( {
jjtree.openIndefiniteNode(ASTMethod.jjtCreate("Method"));
}
 MemberName() ArgumentList(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 ) /*#Method*/ ) |  {
jjtree.openDefiniteNode(ASTField.jjtCreate("Field"));
}
MemberName(){
jjtree.closeDefiniteNode(1);
jjtree.updateCurrentNode(1);
}
 /*#Field(1)*/  )
}

void ArgumentList() /*#void*/ : {}
{
 "(" (  Expression() (  "," Expression() )* )? ")"
}

void DimensionList() /*#void*/ : {}
{
 ( LOOKAHEAD(2147483647,  "[" "]") (  "[" {
jjtree.openIndefiniteNode(ASTEmptyDimension.jjtCreate("EmptyDimension"));
}
"]"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 /*#EmptyDimension*/ ) |  "[" Expression() "]"  )+
}

void AllocationExpression() /*#AllocationExpression*/ : {}
{
{
jjtree.openIndefiniteNode(ASTAllocationExpression.jjtCreate("AllocationExpression"));
}
 "new" FullClassName() ArgumentList(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void ArrayAllocation() /*#ArrayAllocation*/ : {}
{
{
jjtree.openIndefiniteNode(ASTArrayAllocation.jjtCreate("ArrayAllocation"));
}
 "new" FullClassName() DimensionList(){
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void MemberName() /*#MemberName*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTMemberName.jjtCreate("MemberName"));
}
 t=<IDENTIFIER> { try {
ASTMemberName jjtThis = (ASTMemberName)jjtree.currentNode();
jjtThis.name = t.image;
} finally {
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
}

}

void FullClassName() /*#void*/ : {}
{
 ClassName()
|  "$" ClassName() "$"

}

void ClassName() /*#ClassName*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTClassName.jjtCreate("ClassName"));
}
 t=<IDENTIFIER> { try {
ASTClassName jjtThis = (ASTClassName)jjtree.currentNode();
jjtThis.name = t.image;
} finally {
}
}
 (  "." t=<IDENTIFIER> { try {
ASTClassName jjtThis = (ASTClassName)jjtree.currentNode();
jjtThis.name += "." + t.image;
} finally {
}
}
 )*{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}

void Id() /*#Id*/ :
{
Token t;
}
{
{
jjtree.openIndefiniteNode(ASTId.jjtCreate("Id"));
}
 t=<IDENTIFIER> { try {
ASTId jjtThis = (ASTId)jjtree.currentNode();
jjtThis.name = t.image;
} finally {
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
}

}

void Literal() /*#void*/ :
{
Token t;
}
{
 ( ( {
jjtree.openIndefiniteNode(ASTIntConstNode.jjtCreate("IntConstNode"));
}
 t=<INTEGER_LITERAL> { try {
ASTIntConstNode jjtThis = (ASTIntConstNode)jjtree.currentNode();
jjtThis.val = Integer.decode(t.image).intValue();
} finally {
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
}
 ) /*#IntConstNode*/ )
|  ( ( {
jjtree.openIndefiniteNode(ASTFloatConstNode.jjtCreate("FloatConstNode"));
}
 t=<FLOATING_POINT_LITERAL> { try {
ASTFloatConstNode jjtThis = (ASTFloatConstNode)jjtree.currentNode();
jjtThis.val = Double.valueOf( t.image ).doubleValue();
} finally {
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
}
 ) /*#FloatConstNode*/ )
|  ( ( {
jjtree.openIndefiniteNode(ASTCharConstNode.jjtCreate("CharConstNode"));
}
 t=<CHARACTER_LITERAL> { try {
ASTCharConstNode jjtThis = (ASTCharConstNode)jjtree.currentNode();
jjtThis.val = t.image.charAt(1);
} finally {
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
}
 ) /*#CharConstNode*/ )
|  ( ( {
jjtree.openIndefiniteNode(ASTStringConstNode.jjtCreate("StringConstNode"));
}
 t=<STRING_LITERAL> { try {
ASTStringConstNode jjtThis = (ASTStringConstNode)jjtree.currentNode();
jjtThis.val = t.image;
} finally {
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
}
 ) /*#StringConstNode*/ )
|  BooleanLiteral()
|  NullLiteral()

}

void BooleanLiteral() /*#void*/ : {}
{
 {
jjtree.openIndefiniteNode(ASTTrueNode.jjtCreate("TrueNode"));
}
"true"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 /*#TrueNode*/
|  {
jjtree.openIndefiniteNode(ASTFalseNode.jjtCreate("FalseNode"));
}
"false"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}
 /*#FalseNode*/

}

void NullLiteral() /*#NullLiteral*/ : {}
{
{
jjtree.openIndefiniteNode(ASTNullLiteral.jjtCreate("NullLiteral"));
}
 "null"{
jjtree.closeIndefiniteNode();
jjtree.updateCurrentNode(1);
}

}


<DEFAULT> TOKEN : {
<IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)* >
| <#LETTER: ["a"-"z","A"-"Z","_"]>
| <#DIGIT: ["0"-"9"]>
}

