<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html  xmlns="http://www.w3.org/1999/xhtml" xml:lang="de" lang="de" dir="ltr">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  	<title>AGG Documentation</title>
</head>
  <body bgcolor="#ffffff" text="#000044" link="#ff0000" vlink="#000099"
 alink="#00ff00">
  
<center><h1><tt> The AGG Menu Guide  </tt> </h1></center>
<TT> 

<p><a name="Content" id="Content"</a></p>
<div id="toctitle">
<h2>&nbsp;&nbsp;&nbsp;Content</h2>
</div>

<ul>
<li><b>Main Menus</b>
<a name="MainMenus" id="MainMenus"></a>
&nbsp;&nbsp;&nbsp; <a href="#Pop-upMenus"><b>Pop-up Menus<b></a> 
&nbsp;&nbsp;&nbsp; <a href="#TypeEditor"><b>Type Editor<b></a> 

<ul>
<li><a href="#FileMenu">File</a></li>
<li><a href="#EditMenu">Edit</a></li>
<li><a href="#ModeMenu">Mode</a></li>
<li><a href="#TransformMenu">Transform</a></li>
<li><a href="#ParserMenu">Parser</a></li>
<li><a href="#AnalyzerMenu">Analyzer</a>
  <ul>
  <li><a href="#CPA">Critical Pair Analysis</a></li>
  <li><a href="#ARS">Applicability of Rule Sequences</a></li>
  <li><a href="#ConsistencyCheck">Consistency Check</a></li>
  <li><a href="#TerminationofLGTS">Termination of LGTS</a></li>
  </ul>
</li>
<li><a href="#PreferencesMenuOptions">Preferences > Options</a>
  <ul>
  <li><a href="#General">General</a></li>
  <li><a href="#Transformation">Transformation</a></li>
  <li><a href="#Layouter">Layouter</a></li>
  <li><a href="#Parser">Parser</a></li>
  <li><a href="#CriticalPairs">Critical Pairs</a></li>
  </ul>
</li> 

<li><a href="#PreferencesMenuDefaults">Preferences > Defaults</a>
  <ul>
  <li><a href="#Font">Font</a></li>
  <li><a href="#FontSize">Font Size</a></li>
  <li><a href="#Zoom">Zoom</a></li>
  <li><a href="#ShowAttributes">Show Attributes</a></li>
  <li><a href="#KeepTypes">Keep Types On Top</a></li>
  </ul>
</li>

</ul>

<li><b>Pop-up Menus</b> 
<a name="Pop-upMenus" id="Pop-upMenus"></a>
&nbsp;&nbsp;&nbsp; <a href="#MainMenus"><b>Main Menus</b></a>
&nbsp;&nbsp;&nbsp; <a href="#TypeEditor"><b>Type Editor</b></a> 

<ul>
<li><a href="#GraGraPop-upMenu">GraGra</a></li>
<li><a href="#TypeGraphPop-upMenu">Type Graph</a></li>	
<li><a href="#GraphPop-upMenu">Graph</a></li>
<li><a href="#RulePop-upMenu">Rule</a></li> 
<li><a href="#RuleSchemePop-upMenu">Rule Scheme</a></li> 
<li><a href="#RuleSequencePop-upMenu">Rule Sequence</a></li> 
<li><a href="#EditModePop-upMenu">Edit Mode & Operations</a> (background context menu)</li> 
<li><a href="#OperationsPop-upMenu">Operations</a> (context menu of Node and Edge)</li>
</ul>
</li>

<li><b>Type Editor</b> 
<a name="TypeEditor" id="TypeEditor"></a>
&nbsp;&nbsp;&nbsp; <a href="#MainMenus"><b>Main Menus</b></a> 
&nbsp;&nbsp;&nbsp; <a href="#Pop-upMenus"><b>Pop-up Menus</b></a> 

<ul>
<li><a href="#NodeTypeEditor">Node Type editor</a>
<li><a href="#EdgeTypeEditor">Edge Type editor</a>
</ul>
</li>

</ul>

<p><center><b>Main Menus</b></center></p>

<p><a name="FileMenu" id="FileMenu"></a>
&nbsp;&nbsp;&nbsp;<b>File</b></p>
&nbsp;&nbsp;&nbsp;This menu describes how to manipulate graph grammars.
<blockquote>
<table>
<tr><td><b>New GraGra</b><br>
Create a new graph grammar.
</td></tr>
 
<tr><td><b>Open</b><br>
Load a graph grammar. 
</td></tr>
 
<tr><td><b>Save</b><br> 
Save the selected graph grammar in its current file. 
</td></tr>
 
<tr><td><b>Save As</b><br> 
Save the selected graph grammar in a specified file.
</td></tr>
 
<tr><td><b>Open (Base)</b><br> 
Load a base graph grammar (A graph grammar without
layout informations). 
</td></tr>
 
<tr><td><b>Save As (Base)</b><br> 
Save the base graph grammar of the selected grammar. 
</td></tr>
</table>

<table>
<tr><td><b>Export</b></td></tr>
 
<tr><td></td><td>
<b>GXL</b><br>
Convert the selected grammar to GXL, an XML-based
file exchange format for graphs. 
</td></tr>
 
<tr><td></td><td>
<b>GTXL</b><br>
Convert the selected grammar to GTXL, an XML-based
file exchange format for graphs and graph transformation systems.
</td></tr>

<tr><td><b>Import</b></td></tr>
 
<tr><td></td><td>
<b>GGX</b><br> 
Import grammar components (type graph, graph, rule)
in <i>AGG</i> own format.
</td></tr>
 
<tr><td></td><td>
<b>GXL</b><br> 
Import a graph in &nbsp;<b>GXL</b>&nbsp; format.
</td></tr>
 
<tr><td></td><td>
<b>OMONDO</b><br> 
Import an <b>OMONDO XMI (.ecore)</b> class diagram.
</td></tr>
</table>

<table> 
<tr><td><b>Close GraGra</b><br> 
Close the selected grammar. 
</td></tr>
 
<tr><td><b>AGG View to JPEG</b><br> 
Convert and save the view of <i>AGG</i> application to JPEG (.jpg) image. 
</td></tr>
 
<tr><td><b>Quit</b><br> 
Exit this application. 
</td></tr> 
</table>
<br>
Please note: It is also possible to use pop-up menus of <em>GraGra | Type
Graph | Graph | Rule | NAC | PAC | Atomic Constraint | Constraint</em> to obtain their functionalities. 
Such a pop-up menu will appear after pressing the right mouse button when
the cursor points to the corresponding element of the grammar tree. <br>
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="EditMenu" id="EditMenu"></a>
&nbsp;&nbsp;&nbsp;<b>Edit</b></p>
&nbsp;&nbsp;&nbsp;This menu describes how to manipulate  graph objects.
<blockquote> 
<table>

<tr><td><b>Undo Edit</b><br> 
Undo an appropriate edit.
</td></tr>

<tr><td><b>Redo Edit</b><br> 
Redo the last undone edit. 
</td></tr>

<tr><td><b>Discards All Edits</b><br> 
Empty the undo manager. 
</td></tr>

<tr><td><b>Attributes</b> <br>
An attribute editor is opened for 
the picked (by pressing right mouse button) or
selected graph object.<br>
This editor allows:<br>
- to define attributes and set their values,<br>
- to define variables and conditions of the attribute context 
( only for the rule objects),<br>
- to add a new attribute handler.<br>
Please note: If you use a variable for the value of an attribute,  
the variable is added to the attribute context automatically.  
Renaming or deleting this variable does not change the attribute 
context.  You ought to delete non-used variables from the context
 explicitly,  otherwise an error may happen during
match completion or transformation.
</td></tr>

<tr><td><b>Delete</b><br>
Delete all selected graph object(s) and all dangling edges.
</td></tr>

<tr><td><b>Copy</b><br>
Duplicate selected graph object(s).

<table>
<tr><td>
Using <b>Copy</b> icon allows to get a copy of the selected 
graph objects into the same graph (panel) or into a graph (panel) 
that is visible at the same time. <br>
For that aim:<br>
- select graph objects,<br>
- click on <b>Copy</b> icon,<br>
- click on the background of the 
graph panel to place the copy.
</td></tr>
<tr><td>Using <b>Copy</b> in combination with <b>Paste</b> 
you can also get a copy of the selected graph objects into 
another graph (panel) that is not currently visible.
</td></tr>
</table>

</td></tr>

<tr><td><b>Paste</b> <br>
To place selected and copied graph object(s) into another graph.
<table>
<tr><td>
For that aim:<br>
- select graph objects,<br>
- click on <b>Copy</b> icon,<br>
- choose the target graph,<br>
- click on <b>Paste</b> icon,<br>
- click on the background of the graph (panel) to place the copy. 
</td></tr>
</table>

</td></tr>

<tr><td><b>Select Nodes of Type</b><br>
Select all nodes of the current node type.
</td></tr>

<tr><td><b>Select Edges of Type</b><br>
Select all edges of the current edge type.
</td></tr>

<tr><td><b>Select All</b><br>
Select all graph objects. 
</td></tr>

<tr><td><b>Deselect All</b><br>
Deselect all selected objects. 
</td></tr>

<tr><td><b>Straighten Edges</b><br>
All selected edges are straightened.<br>
When no selection is done before, all edges are straightened
and also new created parallel edges will be straightened, too.
To disable this feature, please select an edge and call this
menu item for selected edge again.
</td></tr>

<tr><td><b>Identic Rule</b><br>
An identical rule morphism is created by copying 
the left graph of the rule to the right side. 	
The previous contents of the right side is deleted. 
The object mapping is indicated by the same number. 
</td></tr>

<tr><td><b>Identic NAC</b><br>
An identical NAC morphism is created by copying 	the
left graph of the rule to a NAC graph. 
The previous contents of the NAC graph is deleted. 
The object mapping is indicated by the same number. 
</td></tr>

<tr><td><b>Identic PAC</b><br>
An identical PAC morphism is created by copying the
left graph of the rule to a PAC graph. 	
The previous contents of the PAC graph is deleted. 	
The object mapping is indicated by the same number. 
</td></tr>

<tr><td><b>Identic General AC</b><br>
An identical General (Nested) AC morphism is created by copying the
left graph of the rule to an AC graph. 	
The previous contents of the AC graph is deleted. 	
The object mapping is indicated by the same number. 
</td></tr>
</table>

<br>
Please note: It is also possible to use similar pop-up menus. 
The <em>node</em> or <em>edge</em> pop-up menu
appears after pressing the right mouse button when
the cursor points to a node or the band point of an edge.
</blockquote>  
<a href="#Content">back to Content</a>
  
<p><a name="ModeMenu" id="ModeMenu"></a>
&nbsp;&nbsp;&nbsp;<b>Mode</b></p>
&nbsp;&nbsp;&nbsp;This menu allows to set the mode of 
actions of the <i>AGG</i> grammar editor.	    
<blockquote> 
<table>

<tr><td><b>Draw</b><br>
A node is created by clicking the left
button on the background. 	Nodes are filled with foreground color.
An edge between two nodes is created by clicking on the source 	
and then on the target nodes using the left mouse button. 	
An edge can contain one band only.
 The band can be inserted 	when creating an edge by clicking at the source,  	then
at the background, and then at the target or by grabbing an edge with the
(middle) mouse button at the point 	near the middle of the edge and dragging
it to the desired point.
</td></tr>

<tr><td><b>Select</b><br>	
Objects are selected by pointing with any mouse button 	at
the objects to be selected. Selected nodes and edges turn to green. One click
on the selected object deselects it. Selected objects can be moved, duplicated,
deleted, and selected edges with a band can be straightened. 
</td></tr>

<tr><td><b>Move</b><br> 	
A single node / edge is moved by <em>dragging</em> the mouse button: 	
press the mouse button when the cursor points to a node /
edge, 	move the pointer to the right position and release the button. 	
When a node is moved, incident edges are moved accordingly. 	
Moving leads to the parallel translation of
the selected objects. 
</td></tr>

<tr><td><b>Attributes</b> <br> 	
An attribute editor is opened for the picked object. 
</td></tr>

<tr><td><b>Map</b><br> 	
Toggle mode for interactive creation of the <em>Rule | NAC | PAC | Match</em>
morphism. To add a mapping, first click on an object on the left hand side
of the rule, then click on an object you want to map it to on the right
hand side or in a NAC or in the host graph. If two objects are type,
structure, and attribute compatible, they are labeled by the same number. 
</td></tr>

<tr><td><b>Unmap</b><br> 
To delete a mapping,  click on a mapped object on the left
hand side of the rule;  the <em>Rule | NAC | PAC | Match</em> mapping is deleted. 	
If you click on a mapped object on the right hand side of the rule,  only the rule
mapping is deleted. If you click on an mapped object on the NAC side, the
NAC morphism will be deleted. If you click on an mapped object on the graph
side, only the match morphism will be deleted. 
</td></tr>

<tr><td><b>Image_view</b><br>
When selected and an image is defined for a node type, 
this image will be shown at the node position. 
</td></tr>
</table>

<br>
Please note: It is also possible to use similar pop-up menu by pressing 
the right mouse button on the background of a graph panel. 
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="TransformMenu" id="TransformMenu"></a>
&nbsp;&nbsp;&nbsp;<b>Transform</b></p>	  
&nbsp;&nbsp;&nbsp;This menu allows to perform an in-place graph transformation. 
Additionally, in <i>AGG</i> implemented graph transformation algorithms
 are presented here in very short form.
<blockquote> 

<table>
<tr><td><b>Start</b><br>	
<br>By default, the rules given by a graph grammar are applied 
<b><em>non-deterministically</em></b>.
Rules to be applied and their matches are chosen randomly.<br> 
<i>Algorithm:<br>
rule_set;<br>
applicable= true;<br>
while( applicable ) {<br>
&nbsp;&nbsp; rules= cloneRuleSet( rule_set );<br>
&nbsp;&nbsp; applied= false;<br>
&nbsp;&nbsp; while( not applied & rules not empty ) {<br>
&nbsp;&nbsp; &nbsp;&nbsp; rule= getRandomlyFromRuleSet( rules );<br>
&nbsp;&nbsp; &nbsp;&nbsp; applied= apply( rule);<br>
&nbsp;&nbsp; &nbsp;&nbsp; if( not applied )<br>
&nbsp;&nbsp; &nbsp;&nbsp; removeRuleFromRuleSet( rule, rules );<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; applicable= applied;<br>
}</i><br>

<br>
Next possible kind of graph transformation is transformation 
<b>by rule layers (layered)</b>.
A layer can be set for a single rule or a set of rules.
The layers fix the order of how rules are applied. 
The interpretation process starts with smallest layer.
Once the highest layer has been finished the transformation stops.<br>
<i>Algorithm:<br>
layer_rule_set;<br>
layer= getStartLayer( layer_rule_set );<br>
while( layer exists ) {<br>
&nbsp;&nbsp; rules= getRulesForLayer( layer_rule_set, layer );<br>
&nbsp;&nbsp; applyRandomlyAsLongAsPossible( rules );<br>
&nbsp;&nbsp; layer= getNextLayer( layer_rule_set );<br>
}</i><br>

<br>
Next possible kind is graph transformation 
<b>by rule priorities</b>.
Priority can be set for a single rule or a set of rules.
The rule with the highest priority is always applied first.<br>
<i>Algorithm:<br>
priority_rule_set;<br>
priorityFirst= getFirstPriority( priority_rule_set );<br>
rulesFirst= getRulesForPriority( priority_rule_set, priorityFirst );<br>
applicable= true;<br>
while( applicable ) {<br>
&nbsp;&nbsp; applicable= applyRandomlyAsLongAsPossible( rulesFirst );<br>
&nbsp;&nbsp; applied= false;<br>
&nbsp;&nbsp; priority= getNextPriority( priority_rule_set );<br>
&nbsp;&nbsp; while( not applied & priority exists ) {<br>
&nbsp;&nbsp; &nbsp;&nbsp; rules= getRulesForPriority( rule_set, priority );<br>
&nbsp;&nbsp; &nbsp;&nbsp; applied= applyRandomlyOneRule( rules );<br>
&nbsp;&nbsp; &nbsp;&nbsp; priority= getNextPriority( priority_rule_set );<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; if( applied )<br>
&nbsp;&nbsp; &nbsp;&nbsp; applicable= true;<br>
}</i><br>

<br>
Finally, in some ways deterministically transformation is graph transformation 
<b>by rule sequences</b>.
A transformation rule sequence is a control structure which defines
an ordered set of rule subsequences and rule iterations.<br>
<i>Algorithm:<br>
seq_rule_set;<br>
subseq= getStartSubsequence ( seq_rule_se );<br>
while( subseq exists ) {<br>
&nbsp;&nbsp; rules= getRulesForSubsequence( seq_rule_set, subseq );<br>
&nbsp;&nbsp; subseq_iters= getSubsequenceIterations( seq_rule_set, subseq );<br>
&nbsp;&nbsp; sc= 1;<br>
&nbsp;&nbsp; while( sc <= subseq_iters ) {<br>
&nbsp;&nbsp; &nbsp;&nbsp; while( rules not empty ) {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; rule= getRuleFromRuleSet( rules );<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; rule_iters= getRuleIterations( seq_rule_set, subseq, rule );<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; rc= 1;<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; while( rc <= rule_iters ) {<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; apply( rule );<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; rc++;<br>
&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp; }<br>
&nbsp;&nbsp; &nbsp;&nbsp; sc++;<br>
&nbsp;&nbsp; }<br>
&nbsp;&nbsp; subseq= getNextSubsequence( seq_rule_set );<br>
}</i><br><br>
See also <a href="#Transformation">Transformation</a> options 
for all these kinds.
<br>
At the end, the host graph is modified and shows 
the result of the rule applications. 
</td></tr>

<tr><td><b>Stop</b><br> 	
Stop the running transformation which is started with <b>Start</b>. 
</td></tr>

<tr><td><b>Match</b><br>	
Toggle mode for interactive creation of the match morphism. 
To add a mapping, first click on an object of the left hand side of the
rule, 	then click on the object you want to map to in the host graph. All
match completions are computed automatically by subsequently calling 	<b>Next
Completion</b>. 
</td></tr>

<tr><td><b>Next Completion</b><br> 	
Find the next match of the current rule into the host graph. 
If you have specified a partial match before, you can compute
all its completions by subsequently calling this command. 
</td></tr>

<tr><td><b>Step</b><br> 	
Perform an in-place graph transformation step:  	apply a
rule on the host graph. 	If a match is defined before, this match is used.
Otherwise, a new match is computed. The host graph is modified and shows the
result of the step. 
</td></tr>

<tr><td><b>Undo Step</b><br> 
Undo transformation step. This operation is available after running
transformation has finished.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="ParserMenu" id="ParserMenu"></a>
&nbsp;&nbsp;&nbsp;<b>Parser</b></p>   
&nbsp;&nbsp;&nbsp;The <i>AGG</i> graph parser is able to check, 
if a given graph belongs to a certain
graph language determined by a graph grammar.
<blockquote> 
<table>

<tr><td><b>Open</b><br>  
Open a user dialog to initialize the parser
and change to parser GUI. 
</td></tr>

<tr><td><b>Start</b><br> 
Start the parsing process: parsing of a non-layered or layered
graph grammar  based on critical pair analysis. 
</td></tr>

<tr><td><b>Stop</b><br>  
Stop the parsing process.  
</td></tr>

<tr>
<td><b>back</b><br> 
Return to main AGG GUI.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>

<p><a name="AnalyzerMenu" id="AnalyzerMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Analyzer</b>	  
 
<p><a name="CPA" id="CPA"></a>
&nbsp;&nbsp;&nbsp;<b>Critical Pair Analysis</b> </p>
&nbsp;&nbsp;&nbsp;<b>C</b>ritical <b>P</b>air <b>A</b>nalysis (<b>CPA</b>)
allows to compute all potentially conflicting rule pairs. 
<blockquote> 
<table>

<tr><td><b>Reset</b><br> 
Set the current selected grammar to be a grammar of the CPA GUI. 
</td></tr>

<tr><td><b>Unlock</b> <br>  
Allow edit operations on the grammar that was used for critical pair analysis. 
<br>
Please note: It is necessary to reset the grammar for critical pair analysis, 
after the grammar was unlocked. 
</td></tr>

<tr><td><b>Set Rules</b><br> 
Define the own rule subsets to be checked. 
A dialog containing all rules of the current grammar makes possible to select
two different rule subsets to be checked.
</td></tr>
</table>

<table>
<tr><td><b>Generate</b></td></tr>

<tr><td></td><td>
<b>Conflicts</b><br>  
Change to the CPA GUI, if it is not already done,
and generate parallel conflicts of rule pairs. 
</td></tr>

<tr><td></td><td>
<b>Dependencies</b><br>   
Change to the CPA GUI, if it is not already done,
and generate sequential dependencies of rule pairs. <br>
After that you can see results by selecting rule pairs.<br>
You can also load already saved critical pairs to see results 
or to generate them newly using other options.  
<br>
Please note: It is not possible to edit the grammar after  returning
to main GUI. Use <b>Unlock</b> to make the grammar editable.
<b>Unlock</b> is enabled after the generation has finished or stopped.
</td></tr>
</table>

<table>
  
<tr><td><b>Stop</b><br> 
Stop generation of critical pairs. 
</td></tr>

<tr><td><b>Check Consistency</b><br> 
All generated overlapping graphs are checked against graph 
consistency constraints. 
The number of critical pairs might decrease due to constraints. 
</td></tr>

<tr><td><b>Empty</b><br>  
Empty currently selected container of critical pairs. 
</td></tr>

<tr><td><b>Debug</b><br> 
Change to the CPA GUI where it is possible to generate critical pairs step by step.
After a rule pair is selected, the critical pair analysis starts for
this pair only. 
</td></tr>

<tr><td><b>Save</b><br> 
Save critical pairs.<br>
Combining <b>Debug</b> and <b>Save</b> allows to save subsets
of critical pairs.
</td></tr>
</table>

<table>
<tr><td><b>Load</b></td></tr>

<tr><td></td><td>
<b>In This Window</b><br>  
Load critical pairs in main window. 
</td></tr>

<tr><td></td><td>
<b>In New Window</b><br>
Load critical pairs in a new window.
</td></tr>

<tr><td><b>Show<b></td></tr>

<tr><td></td><td>
<b>Conflicts</b><br>
Show conflicts table. 
</td></tr>

<tr><td></td><td>
<b>Dependencies</b><br> 
Show dependencies table. 
</td></tr>

<tr><td></td><td>
<b>CPA Graph</b><br> 
Show CPA relations graph which contains computed
<i>conflict</i> and <i>dependency</i> pairs. 
</td></tr>
</table>

<table>
<tr><td><b>Check Host Graph</b> <br> 
Check which of the critical rule pairs are applicable to the host graph. 
Only parallel conflicts can be checked. 
</td></tr>

<tr><td><b>back</b> <br>  
Return to main AGG GUI.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>
  
<p><a name="ARS" id="ARS"></a>
&nbsp;&nbsp;&nbsp;<b>Applicability of Rule Sequences</b> </p>
&nbsp;&nbsp;&nbsp;In <i>AGG</i>&nbsp; there is a possibility to check whether a rule sequence
is applicable on a graph or not. We need to check some certain applicability 
(resp. non-applicability) criteria.
Applicability (resp. non-applicability) criteria 
are sufficient but not necessary for the applicability (resp. non-applicability)
of a rule sequence to a graph. 
These criteria can be checked in a static way, 
since they are based mainly on the dependency or independency of rules. 
Moreover, the non-satisfaction of one of the criteria gives a hint to the reason for a rule
sequence to be applicable or not.
More info <a href="ApplicabilityOfRuleSequencesHelp.html"> here </a>.<br> 

Additionally, our Technical Report
<b>Sufficient Criteria for Applicability and Non-Applicability of Rule Sequences</b>&nbsp;
written by L.Lambers, H.Ehrig and G.Taentzer&nbsp;
gives a detailed explanation to this matter. You will find this report
 in the example folder <b>Pizza</b>&nbsp; which is a part of the <i>AGG</i>&nbsp; Examples.

<blockquote> 
<table>
<tr><td><b>Validate</b><br> 
A user dialog allows to check and save rule sequences. 
It also provides a short help description of criteria for the 
applicability (resp. for the non-applicability) of a rule sequence
and explains how to interpret the results.
The results of this check will be shown in separated tables.
</td></tr>

<tr><td><b>Load</b> <br>  
Load a file (.srx) which contains rule sequences with its results of the applicability 
(resp. non-applicability) criteria. This file contains the corresponding graph grammar
which will be loaded in the <i>AGG</i>&nbsp; editor, too.
</td></tr>
</table>
 
</blockquote>
<a href="#Content">back to Content</a>

<p><a name="ConsistencyCheck" id="ConsistencyCheck"></a>
&nbsp;&nbsp;&nbsp;<b>Consistency Check</b></p>	   
&nbsp;&nbsp;&nbsp;Consistency conditions describe
basic properties of graphs as e.g. the existence or uniqueness of certain
elements, independent of particular rules. A graph grammar is consistent 
if the start graph satisfies consistency conditions and the rules preserve
this property.
<blockquote>
<table>
<tr><td><b>Check Atomics</b><br>  
Check if the atomic graphical constraints
are valid. An atomic graphical constraint is valid, 
if it is a total injective morphism. 
</td></tr>

<tr><td><b>Check Constraints</b><br>  
Check if the start graph satisfies all consistency conditions. 
Using <i>Rule</i> pop-up menu makes possible to create or delete 
the rule individual post application conditions. 
After deleting or changing atomic graphical constraints or 
consistency conditions, 
the rule individual post application conditions must be created newly.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="TerminationofLGTS" id="TerminationofLGTS"></a></p>
&nbsp;&nbsp;&nbsp;<b>Termination of LGTS</b>	  

<blockquote> 
In <i>AGG</i>&nbsp; termination criteria 
are implemented for layered graph transformation systems. 
These criteria are defined for typed 
graph transformation with injective rules, injective 
matches and injective negative application conditions (NACs).<br> 
Moreover we define layered graph grammars with deletion and nondeletion layers.
Termination criteria are expressed by deletion and nondeletion layer conditions. <br>
The deletion layer conditions ensure that the last creation of an element with a certain label (type) should precede the first deletion of an element with the same label. On the other hands, nondeletion layer conditions ensure that if an element of a certain label occurs in the LHS of a rule then all
elements  of the same label were already created in previous layers.
<p>
A graph grammar is called &nbsp;<i> layered graph grammar </i>&nbsp; ( <i>LGG</i> )&nbsp; if for each rule &nbsp;<i> r </i>&nbsp; we have a rule layer 
&nbsp;<i> rl (r) = k </i>&nbsp; and 
for each label &nbsp;<i> l </i>&nbsp; a creation layer 
&nbsp;<i> cl (l) </i>&nbsp; and
a deletion layer &nbsp;<i> dl (l) </i>,&nbsp; and a deletion layer 
and a nondeletion layer satisfying the following conditions for
all rules:
<br>
<table><tbody>
<tr>
<td> 
(1) <i> Deletion Layer Conditions </i><br>
------------------------------------------<br>
If &nbsp;<i> k </i>&nbsp; is a deletion layer, then <br>
1. each rule <i> r </i> decreases the number of graph items,  or<br>
2. each rule <i> r </i> decreases the number of graph items of one special  type.<p>
</td>
    </tr> 
    <tr>
      <td> 
        (2) <i> Deletion Layer Conditions </i><br>
        ------------------------------------------<br>
        If &nbsp;<i> k </i>&nbsp; is a deletion layer<br>
        1. <i> r </i>&nbsp; is deleting at least one item <br>
        2. <i> 0 &lt;= cl (l) &lt;= dl (l) &lt;= n </i>&nbsp; for all &nbsp;<i> l </i>  <br>
        3. if &nbsp;<i> r </i>&nbsp; deletes &nbsp;<i> l </i> &nbsp;&nbsp; then &nbsp;<i> dl (l) &lt;= rl (r) </i>  <br>
        4. if &nbsp;<i> r </i>&nbsp; creates &nbsp;<i> l </i> &nbsp;&nbsp; then &nbsp;<i> cl (l) &gt; rl (r) </i>  <p> 
      </td>
    </tr>
    <tr>
      <td> 
      (3) <i> Nondeletion Layer Conditions </i><br>
      -------------------------------------------------<br>
      If &nbsp;<i> k </i>&nbsp; is a nondele<br>tion layer<br>
      1. <i> r </i>&nbsp; is nondeleting, 
      &nbsp; i.e. &nbsp;<i> r : L -> R </i>&nbsp; is total and injective <br>
      2. <i> r </i>&nbsp; has NAC &nbsp;<i> n : L -> N </i>&nbsp; with 
       &nbsp;<i> n' : N -> R </i>&nbsp; injective 
       &nbsp; s.t. &nbsp;<i> n' </i>&nbsp; o <i> n = r </i> <br>
      3. if &nbsp;<i> l </i>&nbsp; occurs in &nbsp;<i> L </i>&nbsp;&nbsp; then &nbsp;<i> cl (l) &lt;= rl (r) </i>  <br>
      4. if &nbsp;<i> r </i>&nbsp; creates &nbsp;<i> l </i>&nbsp;&nbsp; then &nbsp;<i> cl (l) &gt; rl (r) </i> <p> 
	</td>
</tr>
</tbody></table> 

The termination criteria (2) and (3) are defined for typed 
graph transformation with injective rules, injective 
matches and injective negative application conditions (NACs).<br>
The <i> deletion layer conditions </i>&nbsp;(2)&nbsp; ensure that the last creation of an element of a certain type should precede the first deletion of an element of the same type. <br>
On the other hand, &nbsp;<i> nondeletion layer conditions </i>&nbsp;(3)&nbsp; ensure that if an element of a certain type occurs in the LHS of a rule then all
elements  of the same type were already created in this or a previous layer.<br>
A &nbsp;<i>layered graph grammar</i>&nbsp; with deletion and nondeletion layers terminates, 
if for each layer the deletion or nondeletion layer conditions defined above are satisfied.
<br>
The rule layers can be set or generated, the creation
and deletion type layers will be generated automatically. 
</blockquote> 
<a href="#Content">back to Content</a>


<p><a name="PreferencesMenuOptions" id="PreferencesMenuOptions"></a>
&nbsp;&nbsp;&nbsp;<b>Preferences</b>	     
<blockquote> 
<b>Options...</b> for graph matching and transformation, graph layouter,
graph parser, critical pair analysis
<p><a name="General" id="General"></a>
&nbsp;&nbsp;&nbsp;<b>General</b> &nbsp; ( Preferences > Options...)	  
<blockquote>
Following options should be used to direct the matching process.<br>
<b><em>Match completion strategy</em></b> 
<blockquote>
<b>CSP</b> (<b>C</b>onstraint <b>S</b>atisfaction <b>P</b>roblem) 
is used as solution algorithm for the graph matching.<br>
<b>CSP w/o BJ</b> A simplified variant of CSP	
</blockquote> 
<b><em>Match conditions</em></b> 
<blockquote> 
<b>injective / non-injective</b> <br>
<b>dangling</b> condition<br>
<b>identification</b> condition <br>
( note: dangling and identification conditions realize Double Pushout Approach)<br>
<b>NACs</b><br>
A <b>N</b>egative <b>A</b>pplication <b>C</b>ondition of a rule 
prohibits a pattern in a graph when applying a rule.<br>
<b>PACs</b> <br>
A <b>P</b>ositive <b>A</b>pplication <b>C</b>ondition for a rule 
demands a pattern in a graph for its application. Using PACs 
leads to a more compact and concise rule notation.
</blockquote> 
	
The following options can be used for each kind of graph transformation.
(See <a href="#Transformation">Transformation</a> options) <br>
<b><em>Consistency check during transformation</em></b><br> 
It allows to decide how graph consistency constraints
should influence the transformation process: 
<blockquote>
<b>consistent transformations only</b><br>
<b>stop after inconsistent transformation</b></b>
<b>consistent at the end</b></b>
In case of layered graph transformation the consistency check applied 
for each layer.
</blockquote>
	
<b><em>Rule applicability on the host graph</em></b><br>
If this option is set, then after each transformation step
each rule will check whether it is applicable in the context 
of the altered state of the host graph. Visually, the name of 
a non-applicable rule is gray-colored in the grammar tree view. 
It is also possible to check the rule applicability by using
menu item <b>Check Rule Applicability</b> of the <b>GraGra</b> 
pop-up menu. Using <b>Dismiss Rule Applicability</b> menu item 
allows to undo this check and redisplay the rule names.<br>
<p>
<b><em>Graph display settings</em></b> <br> 
<blockquote>
<b>show after step</b><br>
If selected, the altered host graph 
is shown after each graph transformation step during the 
interpretation process, 
otherwise, the altered host graph is only shown
after transformation finished. <br>        
<b>wait after step</b> means that the transformation process 
is paused after each succesful step. The user may make 
closer examination of the altered host graph. 
Entering any key allows to continue the graph transformation. <br>
<b>select new objects after step</b> means that
the new created nodes and edges are
selected after each step with aim to improve the 
visualization of the graph transformation.	
</blockquote>
</blockquote> 
<a href="#Content">back to Content</a>
  
<p><a name="Transformation" id="Transformation"></a></p>
&nbsp;&nbsp;&nbsp;<b>Transformation</b> &nbsp; ( Preferences > Options...)	       
 
<blockquote>
Current <i>AGG</i> application provides four algorithms 
for graph transformation: <br>
<blockquote>
<b>non-deterministically (NT) (by default)</b><br> 
Rules to be applied 
and their matches are chosen randomly. The chosen rule is applied 
as long as possible.<br>
<b>by rule priorities (PT)</b><br>
Each rule or a group of rules get 
a priority number. The smallest priority is the highest.
The rule(s) with highest priority is always applied first as long as possible 
and then the rule(s) with the next priority, and so on.<br>
<b>by rule layers (layered) (LT)</b><br> 
Each rule or a group of rules 
get a layer number. 
The rules with smallest layer are applied first as long as possible 
and then the rules with the next layer, and so on.<br>
<b>by rule sequences (ST)</b> <br>
Each rule or a group of rules can build
a rule sequence respectively a rule subsequence of a sequence.<br>
A transformation rule sequence is a control structure which defines
the order and how often to apply the rules.<br>
To create a rule sequence please use the pop-up menu 
<b>GraGra -> New -> Rule Sequence</b>. A new <b>RuleSequence</b> item will appear
in the GraGra tree view. 
You can rename it by double click at the tree item and retyping the text. 
By selecting the tree item a dialog opens which shows the rule set of the current gragra
and allows to define a rule sequence.<br>
(See also <a href="#RuleSequencePop-upMenu">Rule Sequence</a> pop-up menu)
<br>
Transformation by rule sequences is a possibility in <i>AGG</i>
to apply rules quasi deterministically, because
a transformation rule sequence is a control structure which defines
an ordered set of rule subsequences and rule iterations. 
<br>
(See also <a href="#TransformMenu">Transform</a> menu)
</blockquote>
 
<p>
Following options can be used for <b>layered</b> graph transformation:
<blockquote>		 	
<b>show layer before transform</b><br> 
A rule layer setting dialog is shown 
before transformation starts. It allows to change the rule layer.<br>
<b>loop over layers</b> <br>
This allows to continue
graph transformation by starting on the smallest layer again
 as long as at least one rule is still applicable.<br>
<b>reset graph before loop</b><br>
This option allows to continue 
graph transformation by starting next loop over layers at the initial state of the first host graph.
<br>
 
<b><em>stop current layer and wait</em></b> <br>
The graph 
transformation will pause and wait on the current layer.
Entering any key allows to continue the graph transformation. 
Thereafter, rules of the next layer are applied.<br>
<b>break transformation on current layer</b><br> 
If this option is selected and 
<b>Stop</b> transformation is aktivated the only transformation 
on the current layer is broken. 
The transformation process continues with rules of the next layer.<br>
<b>break layered transformation</b> <br>
If this option is selected and 
<b>Stop</b> transformation is aktivated the whole transformation process
will stop.
</blockquote>
</p>
<p>
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="Layouter" id="Layouter"></a>
&nbsp;&nbsp;&nbsp;<b>Layouter</b> &nbsp; ( Preferences > Options...)</p>	   
&nbsp;&nbsp;&nbsp;A new graph layout algorithm 
<i>"Evolutionary Layout of Graph Transformation Sequences"</i>
for transformed graphs is integrated into <i>AGG</i>.
<blockquote> 
The options for the graph layouter include: <br>
<b><em>perform during graph transformation</em></b> <br>
If selected, 
the new layout algorithm is used to layout transformed graphs.<br>
<b><em>write to directory</em></b> <br>
If selected, each graph of the
graph transformation sequence is converted to JPEG image (.jpg) and 
written to a user defined directory. The directory can be chosen 
by a file chooser dialog before.<br>
<b><em>write to (.log) file</em></b> <br>
If selected, the layout metrics are written into 
a grammar_name.log file in the user defined derectory.<br>
<b><em>use layout pattern</em></b> <br>
If selected, a set of layout patterns is available 
which allows to direct the graph layouter. This option is only enabled when
the option <b><em>perform during graph transformation</em></b> is selected.<br>
<br>
<b>General</b> layout pattern include:<br>
<b><em>iteration count of layout process</em></b> <br>
It is used to set 
the count of layouting iterations to run.<br>
<b><em>initial temperature of cooling</em></b> <br>
It is used to set initial temperature for initial layout.<br>
<b><em>preferred edge length</em></b> <br>
It defines the preferred length for all
edges of transformed graphs.
<br>
<b><em>span of node cluster </em></b> <br>
It is used to set the distance
between a node and its neighbour nodes which are connected by outgoing 
edges.<br>
Please note: The done changes are accepted after RETURN key is pressed.<br>
<br>
<b>Edge Type Tattern</b> include pattern for <b>X</b> and <b>Y</b>-axis 
and <b><em>preferred length</em></b>.<br>
<br>
<b>Node Type Tattern</b> allows still to fix the current position 
of nodes of the selected type.<br>  
<br>
<b><em>Table of Graph Layout Pattern</em></b> shows all
user defined pattern for node and edge types.<br>
<br>
Please note: If the option <b><em>use layout pattern</em></b> is not
selected, the only default layout pattern of this algorithm is used.
<br>
Of course, 
this graph layout algorithm can only try to approximate 
the current layout of a graph to a graph layout defined by 
the layout pattern. Increasing iteration count of the layout process
and initial temperature of cooling may help to achieve
a better approximation but would increase the cost in time.
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="Parser" id="Parser"></a>
&nbsp;&nbsp;&nbsp;<b>Parser</b> &nbsp; ( Preferences > Options...)</p>	   
<blockquote>      
The options for parsing include: <br>
<b><em>Parser display option</em></b><br>
It is used to configure the 
visualization of the parsing process.
<b><em>Algorithm for parser</em></b><br>
<i>AGG</i> offers three different  variants of a parsing algorithm
being based on backtracking. 
The parser builds up a derivation tree of possible 
reductions of the host graph. The leaves of this tree are
either dead ends, i.e. leave graphs where no rule
can be applied anymore but non-isomorphic to the stop
graph or the stop graph. In this case, the parsing was successful.
<blockquote>
<b><em>Critical Pair Analysis</em></b><br>
This parser exploits critical pair analysis for rules what allows
to make parsing of graphs more efficient: 
decisions between conflicting rule applications are 
delayed as far as possible. This means that non-conflicting rules
are applied first to reduce the graph as much as possible. 
Afterwards, the conflicting rules are applied, first in non-critical 
situations and when this is not possible, in critical once. 
In general, this optimization reduces the derivation tree
constructed, but does not change the worst case complexity.
<br>
<b><em>Semi optimized backtracking</em></b><br>
This is a simplified parser being based on critical pairs.
This means that non-conflicting rules
are applied first to reduce the graph as much as possible.
Afterwards, the conflicting rules are applied in any situation.<br> 
<b><em>Backtracking without optimization</em></b><br>
This is the simple backtracking parser with exponential time complexity.
</blockquote>
<b><em>layered</em></b> <br>
Please note:
The rule layers  defined
before are used for critical pair analysis and parsing. 
The rule layers are identical with the layers 
for the graph transformation. 
</blockquote>
<a href="#Content">back to Content</a>
 
<p><a name="CriticalPairs" id="CriticalPairs"></a></p>
&nbsp;&nbsp;&nbsp;<b>Critical Pairs</b>	&nbsp; ( Preferences > Options...)  

<blockquote>
The options for critical pair analysis include: <br>
<b><em>Select the kind of critical pairs to compute</em></b> <br>
<blockquote>
<b><em>conflicts</em></b><br>
The implemented algorithm
detects parallel conflicts between rule applications.<br>
These conflicts are of the kind:
<ul>
<li>the first rule deletes objects which the second rule needs</li>
<li>the first rule produces objects which the second rule does not allow</li>
<li>the first rule changes attributes which the second rule uses</li>
</ul>
<br>
<b><em>trigger dependency</em></b><br>
The implemented algorithm
detects sequential trigger dependencies between rule applications.<br>
These dependencies are of the kind:
<ul>
<li>the first rule produces objects which the second rule needs</li>
<li>the first rule deletes objects which the second rule does not allow</li>
<li>the first rule changes attributes so that they can be used by the second rule</li>
</ul>
<br>
<b><em>trigger & switch dependencies</em></b><br>
The implemented algorithm
detects sequential trigger and switch dependencies between rule applications.<br>
These dependencies are similar to  <b><em>trigger dependency</em></b>.
Additionally, it checks whether two rules are in <em>deliver-delete</em> (resp. <em>forbid-produce</em>) 
dependency. That means the second rule deletes (produces) something 
what the first rule delivers (forbids), 
so that the first rule is irreversible after the second is applied.
</blockquote>

<b><em>layered</em></b><br>
Please note:
The rule layers defined for the layered graph transformation
'are used for critical pair analysis and parsing, too.
The rule layers are identical with the rule layers of the 
graph transformation.<br>
<b><em>complete</em></b> <br>
If selected, complete generation (searching all possible matches)
of critical pairs will be done, if not selected, 
searching up to first critical match. <br>
<b><em>consistent</em></b> <br>
If selected, all overlapping graphs generated during  
computation of critical pairs will be checked against graph consistency constraints.
The number of critical pairs migth decrease due to constraints.<br>
Please note: Because a critical graph is a minimal graph 
of a conflicting situation, it is not always possible to check
all graph consistency constraints, especially constraints (formulae)
with negation of atomic graph constraints.
Also attribute conditions and constant values of the attributes
could not be evaluated for each graph. 
This option is deselected by default.<br>
<b><em>strong</em></b> <br>
If selected, extended attribute checking will take place.
That means, the first rule changes an attribute value of a graph object,
but the second rule uses this attribute value as constant value 
or as a target value of an input parameter 
or as a target value of a variable which is part of an attribute condition.					
The number of critical pairs may decrease therefore.<br>						
<b><em>ignore pairs with same rules</em></b> <br>
If selected, 
critical pairs of rule pairs with same rules
are ignored during computation. Otherwise, they are computed, too.<br>
<b><em>ignore pairs with same rules and same matches</em></b> <br>
If selected, 
critical pairs of rule pairs with same rules and same matches
are ignored during computation. Otherwise, they are computed, too.<br>
<b><em>essential</em></b> <br>
An essential critical pair exists for each conflict reason.
It expresses the conflict caused by exactly this conflict
reason in a minimal context. Essential critical pairs
is a subset of critical pairs.<br>
<br>
<b><em>Display Settings</em></b><br>
They allow to set the number of displayed critical pairs and
initial window size of overlapping graphs.
</blockquote>
</blockquote>
<a href="#Content">back to Content</a>


<p><a name="PreferencesMenuDefaults" id="PreferencesMenuDefaults"></a></p>
&nbsp;&nbsp;&nbsp;<b>Preferences</b>	     
<blockquote> 
<b>Defaults</b> for graphical visualization support
<p>
<a name="Font" id="Font"></a>
&nbsp;&nbsp;&nbsp;<b>Font</b>	  
<blockquote>
Set text font: <em>Plain</em> or <em>Bold</em>.  
</blockquote>
<a name="FontSize" id="FontSize"></a>
&nbsp;&nbsp;&nbsp;<b>Font Size</b>	  
<blockquote>
Set size of the current text font.
</blockquote>
<a name="Zoom" id="Zoom"></a>
&nbsp;&nbsp;&nbsp;<b>Zoom</b>	  
<blockquote>
Set zooming size of graphics.
</blockquote>
<a name="ShowAttributes" id="ShowAttributes"></a>
&nbsp;&nbsp;&nbsp;<b>Show Attributes</b>
<blockquote>
Allows to set visibility of the attributes of nodes and edges
for graphs, rules and type graph separately. 
</blockquote>
<a name="KeepTypes" id="KeepType"></a>
&nbsp;&nbsp;&nbsp;<b>Keep Types On Top</b>	  
<blockquote>
Allows to keep the type palette to be visible during additing types and graphs. 
</blockquote>
</blockquote>
<a href="#Content">back to Content</a>
<p><center><b>Pop-up Menus</b></center></p>


<p><a name="GraGraPop-upMenu" id="GraGraPop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>GraGra</b>
<blockquote>

<table>
<tr><td> <b>New</b></td></tr> 

<tr><td></td><td>
<b>Type Graph</b><br>
Create a new type graph for the selected grammar.
</td></tr>

<tr><td></td><td>
<b>Graph</b><br>
Create a new host graph for the selected grammar.
</td></tr>

<tr><td></td><td>
<b>Rule</b> <br>
Create a new rule for the selected grammar.
</td></tr>

<tr><td></td><td>
<b>Rule Scheme</b><br>
Crate a new rule scheme for the selected grammar.
<br> A rule scheme is used to generate an amalgamated rule
with aim to perform amalgamated graph transformation.
</td></tr>

<tr><td></td><td>
<b>Atomic Constraint</b><br>
Create a new atomic graphical consistency
constraint (GCC) for the grammar.
</td></tr>

<tr><td></td><td>
<b>Constraint</b><br>
Create a new consistency condition (CC) (boolean formula) for a
grammar. Constraints are build up over the GCCs of a grammar. 
Each GCC corresponds to a variable inside of boolean formula.
After the host graph is checked, each variable will get value <i>TRUE</i>
or <i>FALSE</i> and formulae can be evaluated.  
A host graph satisfies consistency conditions, if the
result value of each formula is TRUE.<br> 
To edit a constraint, please use its pop-up menu.
</td></tr>

<tr><td></td><td>
<b>Rule Sequence</b><br>
Create a new rule sequence for the selected grammar with aim to check
applicability of this rule sequence, but also to use it for graph transformation.<br>
(See also <a href="#RuleSequencePop-upMenu">Rule Sequence</a> pop-up menu)
</td></tr>
    
<tr><td></td><td>
<b>Add Copy of Current Host Graph</b><br>
Make a copy of the current host graph and add it to the grammar.
</td></tr>  
                            
<tr><td><br><b>Layering</b></td></tr>

<tr><td></td><td>
<b>Set Rule Layer</b><br>
A table with rules appears to set the layer of each rule. 
These layers will be used during layered graph transformation.
</td></tr>

<tr><td></td><td>
<b>Select Rule Layer for Constraint</b><br>
A table with consistency conditions (formulae) appears to set the layer(s) of each formula. 
These layers will be used during layered graph transformation. 
A consistency condition must be satisfied on its layer only.
</td></tr>
   
<tr><td></td><td>
<b>Set Trigger Rule for Layer</b><br>
For each layer one rule may be set as trigger
for this layer. The trigger rule is applied as first rule and only once.
All other rules are applied as long as possible.
If the trigger rule is not applicable, the corresponding 
layer is not executed at all. 
</td></tr>
  
<tr><td></td><td>
<b>Sort Rules by Layer</b><br>
The rules will be sorted according layers.
</td></tr> 

<tr><td></td><td>
<b>Sort Constraints by Layer</b><br>
The constraints will be sorted according layers.
</td></tr>
  
<tr><td></td><td>
<b>Disable Rule Layer</b><br>
All rules of the selected layer will be disabled.
</td></tr>  

<tr><td><br><b>Priority</b></td></tr>

<tr><td></td><td>
<b>Set Rule Priority</b><br>
A table of rules appears to set priority of each rule. 
These priorities will be used during graph transformation by rule priorities.
</td></tr>

<tr><td></td><td>
<b>Select Rule Priority for Constraint</b><br>
A table with consistency conditions (formulae) appears to select priority for each formula. 
These priorities will be used during graph transformation by rule priorities. 
A consistency condition has to be satisfied for the selected priority only.
</td></tr>
   
<tr><td></td><td>
<b>Sort Rules by Priority</b><br>
The rules will be sorted according priorities.
</td></tr>

<tr><td></td><td>
<b>Sort Constraints by Priority</b><br>
The constraints will be sorted according priorities.
</td></tr>
</table>

<table>                                              
<tr><td><br><b>Check Rule Applicability</b><br>
Check each rule whether it is applicable in the context 
of the current state of the host graph. 
Visually, the name of a non-applicable rule is gray-colored 
in the grammar tree view. 
</td></tr>

<tr><td><br><b>Dismiss Rule Applicability</b><br>
Dismiss the rule applicability check and redisplay the rule names.
</td></tr>
</table>

<table>  
<tr><td><br><b>Consistency</b></td></tr> 
               
<tr><td></td><td>
<b>Check Atomics</b><br>
Check if atomic graphical consistency
constraints are valid. An GCC is valid, 
if it is a total injective morphism. 
</td></tr>

<tr><td></td><td>
<b>Check Constraints</b><br>
Check if the work graph satisfies the consistency conditions.
</td></tr>    
     
<tr><td></td><td>
<b>Create Post Application Conditions</b><br>
Transform global consistency conditions
into post-application conditions  for each rule. A so-constructed rule is applicable
to a consistent graph if and only if the derived graph is consistent, too. 
</td></tr>
</table>

<table>
<tr><td><br><b>Close</b><br>
Close this grammar. 
</td><td></td></tr>

<tr><td><br><b>Save</b><br>
Save this grammar. 
</td><td></td></tr>
 
<tr><td><br><b>Save As</b><br>
Save this grammar into the specified file. 
</td><td></td></tr>          
</table>

<table>
<tr><td><br><b>Export</b></td></tr>

<tr><td></td><td>
<b>JPEG</b><br> 
Convert the host graph of the selected grammar to an JPEG (.jpg) image.
<td></tr>

<tr><td></td><td>
<b>GXL</b><br> 
Convert the selected grammar to GXL, an XML-based
file exchange format for graphs.
<td></tr>

<tr><td></td><td>
<b>GTXL</b><br> 
Convert the selected grammar to GTXL, an XML-based
file exchange format for graphs and graph transformation systems.
</td></tr>
 
<tr><td></td><td>
<b>COLOR GRAPH</b><br> 
Convert the currently selected host graph of the current grammar to 
<b>Coloring Problems Graph Format</b>.
This format is a flexible format suitable for many types of graph problems.
The output file will end with (<b>.col</b>).<br>
This output file can be used as input file for tools which provide algorithms
and heuristics for graph problems, i.e., <b>Greedy Coloring</b> algorithm<br>
( see &nbsp; http://www.cs.ualberta.ca/~joe/Coloring/index.html#Graph.Colorers <br>
 and &nbsp; http://www.cs.ualberta.ca/~joe/Coloring/Colorsrc/manual.html#greedy <br>
for format description of (.col) see paper 
<i>Clique and Coloring Problems Graph Format</i> ).<br>
The Greedy algorithm, also known as the sequential  algorithm.
The Greedy takes each vertex in turn in some predefined order 
and tries to color the vertex with one of the colors used so far. 
In other words, it tries to add the vertex to one of the existing color classes. 
If it is not possible to color it with any existing color, 
then a new color class is created and the vertex is assigned the color of that class.<br>
The output file of <b>Greedy Coloring</b> ends with (<b>.col.res</b>)
and can be imported by AGG.
</td></tr> 
 
<tr><td><br><b>Import</b></td></tr>
 
<tr><td></td><td>
<b>GGX</b><br> 
Import grammar components &nbsp; in <i>AGG</i> own format.
</td></tr>
 
<tr><td></td><td>
<b>GXL</b><br> 
Import a graph&nbsp; in <b>GXL</b> format.
</td></tr>
 
<tr><td></td><td>
<b>OMONDO</b><br> 
Import an &nbsp;<b>OMONDO XMI (.ecore)</b>&nbsp; class diagram.
</td></tr>
  
<tr><td></td><td>
<b>COLOR GRAPH</b><br>
Try to integrate results of tools for <b>Coloring Problems</b>  
into nodes of the currently selected host graph of the current grammar.
The input file must end with (<b>.col.res</b>).<br>
( See &nbsp; http://www.cs.ualberta.ca/~joe/Coloring/index.html#Graph.Colorers <br>
 and &nbsp; http://www.cs.ualberta.ca/~joe/Coloring/Colorsrc/manual.html#greedy <br>
 for format description of (.col.res) see paper 
<i>Clique and Coloring Problems Graph Format</i> ).<br>
The color values of the import file will be used for values of <b>color</> attribute
of nodes of the current host graph. The <b>color</> attribute should be of type <b>int</b>
or <b>String</b>.
</td></tr> 
</table>

<table>         
<tr><td><br><b>Reset Graph</b><br>
PLEASE NOTE: This is an item of the <b>Graph</b> Pop-up menu now.<br>
The currently selected host graph of a grammar will be rewritten by a copy 
of the (first) host graph. This graph copy is done after a grammar is loaded in AGG.
</td></tr>
  
<tr><td><br><b>Reload</b><br>
Currently selected grammar is loaded again.
</td></tr>
 
<tr><td><br><b>Textual Comments</b><br>
A simple text editor allows to put some comments to the specified grammar.
</td></tr>
</table>

</blockquote>
<a href="#Content">back to Content</a>


<p><a name="TypeGraphPop-upMenu" id="TypeGraphPop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Type Graph</b>

<blockquote>
This menu describes the behavior of the type graph check and 
how the type graph is used. 
<table>

<tr><td><b>disabled</b><br>
The type graph is ignored, thus all graphs can contain objects
with types defined in the type set of the grammar. Multiplicities are
also ignored.
</td></tr>

<tr><td><b>enabled</b><br>
The type graph is basically used. Thus, all graphs may only contain
objects of types defined in the type graph. The type multiplicities are
not checked.
</td></tr>

<tr><td><b>enabled with max</b><br>
The type graph is basically used. Thus, all graphs can only contain
objects with types defined in the type graph. Multiplicities in all
graphs should satisfy the defined maximum constraints.
</td></tr>

<tr><td><b>enabled with min and max</b><br>
The type graph is used. Thus, all graphs can only be typed 
above node and edge types defined in the type graph. 
All graphs of a grammar must satisfy maximum constraints 
of type multiplicity and the host graph must satisfy
the minimum constraints in addition.
</td></tr>

<tr><td><b>Delete</b><br>
The type graph is destroyed. Afterwards, all graphs are typed
above types defined in the type set of the grammar. 
</td></tr>

<tr><td><b>Textual Comments</b><br>
A simple text editor allows to put some comments 
to the specified type graph.
</td></tr> 
</table>

<p>  
If the type graph check is set, the type graph is
used during all graph changes. </p>

<p><a name="EditingTypeGraph" id="EditingTypeGraph"></a></p>
<b>Editing Type Graph</b>
<p>
A type graph is created by using menu item  <b>New > Type Graph</b> 
of the &nbsp;<em>gragra</em>&nbsp; pop-up menu. 
After selecting its entry in the tree view an empty graph is loaded 
in the graph editor. 
Editing type graph is similar to the editing a host graph of a grammar,
also the attributes of nodes and edges can be set by default values.<br>

The &nbsp;<em><b>multiplicity</b></em>&nbsp; of a node resp. edge type can be set 
in a multiplicity dialog 
which appears after selecting item <b>Multiplicity</b> 
from the context pop-up menu of a node resp. edge.<br> 
The <b>node type multiplicity</b> defines how many nodes 
can be created in a host graph.<br>
The <b>edge type multiplicity</b> includes source and target multiplicity.
The <b>source multiplicity</b> defines how many nodes of the source node type
can be connected by this edge type to a node of the target node type.
The <b>target multiplicity</b> defines how many nodes of the target node type
can be connected by this edge type to a node of the source node type.
<p>
A type graph can be enriched 
with <b>inheritance relations</b> between nodes.  
Each node type may have more then one direct ancestor (parent) 
from which it inherits the attributes and edges. 
A parent node can be set by choosing item <b>Set Parent</b> of the context
pop-up menu and clicking the left button on the appropriate node.
An inheritance edge is added to show the defined relation.
A parent node can be unset using item <b>Unset Parent</b> and 
 clicking the left button on the parent node.<br>
Additionally, a parent node type can be declared as an abstract type
by selecting item <b>Abstract</b> of the context 
pop-up menu. 
It is allowed to use an abstract node type for nodes of rules
and graph constraints, 
but it should not be used for creating nodes of a host graph.<br>
 
Please note:<br>
The <em><b>multiplicity</b></em> of a parent node type does also 
effect the number of the instances of a child type in a host graph. 
Since all instances of the child types are instances of a parent type, 
the sum is limited by the <em>multiplicity</em> of this parent type.<br>
Similiar for the inherited edges -  
the overall number of incoming / outgoing edges is limited by 
the <em>multiplicity</em> of the edge type incoming to / outgoing from
the parent node type.
<p>
Furthermore, using item <b>Hide Objects of Type</b> makes possible
to hide all instances of this type in a host graph. The appropriated type object in the
type graph is gray colored now. Use <b>Show Objects of Type</b> to get its instances 
to be visible again.

</blockquote>
<a href="#Content">back to Content</a>	

<p><a name="GraphPop-upMenu" id="GraphPop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Graph</b>

<blockquote>
This pop-up menu describes operations of a host graph. 

<table>
<tr><td><b>Reset</b><br>
The pointed host graph is reset to the start graph of its grammar.
</td></tr>

<tr><td><b>Delete</b><br>
The pointed host graph is deleted. 
The last host graph cannot be deleted anymore.
</td></tr>

<tr><td><b>Textual Comments</b><br>
A simple text editor allows to put some comments to the pointed host graph.
</td></tr> 
</table>
<p> 
</blockquote>
<a href="#Content">back to Content</a>	


<p><a name="RulePop-upMenu" id="RulePop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Rule</b>
<blockquote>
This pop-up menu describes all possible operations of a rule.  

<table>
<tr><td><b>New General Application Condition</b><br>
Create a <b>G</b>eneral <b>A</b>pplication <b>C</b>ondition for rule application.
A GAC determines a pattern in a graph to apply a rule.
General application conditions are closed under boolean formula.
The negation of a GAC is equivalent to a NAC, the positive expression - to a PAC of a rule.<br> 
Moreover, a general rule application condition can be refined by one or more
general application conditions. The nested structure of a GAC
allows to increase the expressiveness of local changes of graph transformations.
</td></tr>

<tr><td><b>Set Formula above General Application Conditions</b><br>
Allow to define a boolean formula above GACs.<br>
A formula will be represented by a binary tree graph.  
It can be edited by using the background and node pop-up menus of the graph.
To hold the graph more compact some simplifications are used.  
(Exmpl.: <b>ac</b> is equivalent to <i>EXISTS(ac, true)</i>,
<b>!ac</b> is equivalent to <i>NOT EXISTS(ac, true)</i>)<br>
An empty graph means that all condition nodes are connected by <i>AND</i> operator. 
</td></tr>

<tr><td><b>New NAC</b><br>
Create a NAC (<b>N</b>egative <b>A</b>pplication <b>C</b>ondition)
for rule application.
A NAC forbids a pattern in a graph to apply a rule.
</td></tr>

<tr><td> <b>New PAC</b><br>
Create a PAC (<b>P</b>ositive <b>A</b>pplication <b>C</b>ondition) 
for rule application.
On the contrary to a NAC, a PAC demands a pattern in a graph 
to apply a rule.
Using PACs leads to a more compact and concise rule notation.
</td></tr>

<tr><td> <b>Create Post Conditions</b><br>
Post application conditions of a rule are generated 
using consistency conditions
such that a graph grammar ensures consistency during rule application.
Please note:
Post application conditions are not supported for graph grammars 
with node type inheritance.
</td></tr>

<tr><td><b>Delete Post Conditions</b><br>
Delete Post application conditions of a rule.
</td></tr>

<tr><td> <b>Set Layer</b><br>
Set rule layer that is used during layered graph transformation.
</td></tr>

<tr><td> <b>Set Priority</b><br>
Set rule priority that is used during graph transformation by rule priority.
</td></tr>

<tr><td> <b>Parallel Matching</b><br>
Set so-called "parallel" matching mode for rule application.
That means, a rule is applied "simultaneously"
on all valid "parallel" matches found in the current state of the host graph.
Only after all possible "parallel" rule applications are
done the structural changes of the host graph will take effect
on finding next valid "parallel" matches.<br>
Please note, at the time this new feature is in experimental phase.
One should be careful when using it.
</td></tr>

<tr><td> <b>Move</b><br>
Moving rule to another position inside of rule set of its grammar.
</td></tr>

<tr><td> <b>Copy</b><br>
Add a rule copy to the same grammar.<br>
To copy a rule from another grammar is possible by using
<b>Import > GGX</b> of the menu <b>File</b>
or <i>GraGra</i> pop-up menu.
</td></tr>

<tr><td><b>Make Inverse Rule</b><br>
Revert an injective rule: left graph will be the RHS, right graph - the LHS, 
the objects to delete are now to be created,  the objects to create are now to be deleted.
Application conditions (NACs, PACs, General (Nested) ACs and attribute conditions) will be converted when it is
possible. (A warning massage dialog shows conditions failed.) 
The attribute expressions inside the RHS of the current rule will be replaced by a variable inside the LHS of 
the new rule.
The successful reverted rule is added to the rule set. 
</td></tr>

<tr><td><b>Make Minimal Rule</b><br>
The minimal rule is extracted from a given rule. 
A minimal rule comprises the effects of a given rule in a minimal context.
The application conditions (NACs, PACs, General ACs) are not taken in account. 
</td></tr>

<tr><td> <b>Delete</b><br>
Delete this rule.
</td></tr>

<tr><td> <b>disabled</b><br>
Disable this rule. A disabled rule is not taken in account during graph transformation.
</td></tr>

<tr><td> <b>animated</b><br>
This option can be used with positive effect for a rule which
deletes and then creates an outgoing edge from the same source node to  
an other target node. The source and target nodes should be preserved
by this rule. 
Moreover, it is needed that the type of the source node is declared to be animated, too.
This can be done in the <b>Node Type Editor</b> which is a part of the <i>AGG</i> Type Editor.
</td></tr>

<tr><td> <b>Wait Before Apply Rule</b><br>
The transformation process 
is paused before to apply this rule. The user may make 
closer examination of the match. 
Entering any key allows to continue the graph transformation. 
</td></tr>

<tr><td> <b>Textual Comments</b><br>
A simple text editor allows to put some comments to the specified rule.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>	


<p><a name="RuleSchemePop-upMenu" id="RuleSchemePop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Rule Scheme</b>
<blockquote>
This pop-up menu describes all possible operations of a rule scheme.  
A rule scheme is a group of rules consisting of exactly one kernel rule and 0..* multi rules.
The kernel rule is automatically included into each multi rule.
Therefore a multi rule is an extension on the kernel rule. 
It normally contains the optional elements.
<table>
<tr><td><b>New Multi Rule</b><br>
Create a new multi rule as extention on the kernel rule.
The nodes and edges of the kernel rule are connected to its copies inside of a multi rule.
Moreover, the objects of the kernel rule cannot be changed or deleted from a multi rule.
This is only allowed for the kernel rule. 
If the kernel rule was modified, all the multi rules will automatically follow. 
<br>
When running transformation AGG is trying to match a rule scheme. 
It will try to find the "largest" amalgamation (combination) of the multi rules 
such that it matches in the host graph. Such a combination can include just one of the
multi rules, or just the kernel rule. If AGG can't find any matching combination, 
the rule scheme doesn't match.
      
</td></tr>

<tr><td> <b>parallel Match of Kernel Rule</b><br>
If selected, AGG tries to use "parallel" matching for the kernel rule and to create amalgamation
based on all found kernel matches which are conflict free.
Otherwise, only first found kernel match is used for amalgamation.
</td></tr>

<tr><td> <b>conflict free Match of Multi Rule</b><br>
If selected, only use-delete conflict free matches of multi rules are used for amalgamation.
Otherwise, all found multi matches free are taken in account.  
</td></tr>

<tr><td> <b>disjoint Match of Multi Rule</b><br>
If selected, only disjoint matches of multi rules are used for amalgamation.
Otherwise, also jointly (conflict free) multi matches are allowed.  
</td></tr>

<tr><td><b>apply at least One Multi Rule</b><br>
If selected, at least one multi rule must be applicable. Otherwise the rule scheme doesn't match.
</td></tr>

<tr><td> <b>Create Amalgamated Rule</b><br>
AGG will apply the rule scheme to the current host graph and then add the amalgamated (unmodifiable)
rule that already has a match at the host graph. 
This will fail if AGG doesn't find any combination that matches.
Please note, that the match of the kernel rule can be also set manuelly.
It will be taken in account during amalgamation process. 
After the transformation step done, the amalgamated rule is destroyed. <br>
The possibility to create an amalgamated rule manuelly is only useful for the testing purpose.
</td></tr>

<tr><td><b>Make Inverse Rule Scheme</b><br>
Revert a rule scheme: its kernel rule and multi rules will be reverted. The rules must be injective.
Application conditions (NACs, PACs, General (Nested) ACs and attribute conditions) will be converted when it is
possible. (A warning massage dialog shows conditions failed.) 
The attribute expressions inside the RHS of the rules will be replaced by a variable inside the LHS on the new rules.
The successful reverted rule scheme is added to the rule set. 
</td></tr>

<tr><td><br>All other items of the <i>Rule Scheme</i> pop-up menu are like items of the <i>Rule</i> pop-up menu.
</td></tr>

</table>
</blockquote>
<a href="#Content">back to Content</a>	

<p><a name="RuleSequencePop-upMenu" id="RuleSequencePop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Rule Sequence</b>
<blockquote>
<table>
<tr><td><b>Show / Edit</b><br>
The <a href="RuleSequencesHelp.html"><i>Rule Sequence</i> dialog </a> shows the rule set of the current gragra
and allows to define a rule sequence.
</td></tr>

<tr><td> &nbsp;&nbsp;&nbsp;&nbsp; Next three items deal with construction of concurrent rules built from a plain rule sequence.
A plain rule sequence contains several rules only. Each rule can be applied once. The user can make such a plain rule sequence in
the <a href="RuleSequencesHelp.html"><i>Rule Sequence</i> dialog </a> by creating only one subsequence 
and adding the rules into.<br>   
A concurrent construction is performed from a plain rule sequence by iterative procedure. 
The first two rules build the first concurrent rule. This concurrent rule and the next rule in the sequence
build the next concurrent rule and so on. The last concurrent rule is the resulting rule.
The application conditions
(NACs, PACs, attribute conditions) of each rule of the sequence are converted to the appropriate conditions 
of the resulting rule. 
NOTE: The General (Nested) Application Conditions are not shifted (not jet implemented).
Thus a concurrent construction summarizes all changes of the corresponding rule sequence into a single rule.
</td></tr>

<tr><td><b>Make (max) Concurrent Rule jointly by Dependency</b><br>
Construct a concurrent rule from the current plain rule sequence. 
For each two rules, the intersection of the RHS of the first and the LHS of the second rule 
is defined by the maximal dependency (an overlapping over nodes and edges). 
</td></tr>

<tr><td><b>Make Concurrent Rule(s) jointly by Dependency</b><br>
Construct a concurrent rule from the current plain rule sequence. 
For each two rules, the intersection of the RHS of the first and the LHS of the second rule 
is defined by dependency (an overlapping over nodes and edges). In case of several overlappings,
several concurrent rules can be generated.
</td></tr>

<tr><td><b>Make Concurrent Rule jointly by Object Flow</b><br>
Construct a concurrent rule from the current plain rule sequence. 
For each two rules, the intersection of the RHS of the first and the LHS of the second rule 
is specified by user defined object flow.  
An object flow can be set in an <i>Object Flow</i> dialog which is available  
from the <a href="RuleSequencesHelp.html"><i>Rule Sequence</i> dialog </a>.
</td></tr>

<tr><td><b>Make Parallel Rule by disjoint Union</b><br>
Construct a parallel rule from the current plain rule sequence.
The new rule is built by the disjoint union of the corresponding graphs and morphisms of all rules. 
The application conditions (NACs, PACs, attribute conditions) of each rule are shifted to the resulting 
parallel rule.
</td></tr>

<tr><td><b>Delete</b><br>
Delete the currently selected rule sequence.
</td></tr>

<tr><td><b>Graph Transformation by validated Rule Sequence</b><br>
If selected, the graph transformation will be controlled by the currently selected rule sequence.
This sequence should be valid after it is checked by <a href="#ARS"> <i>Applicability of Rule Sequences</i> check</a> before.
</td></tr>

<tr><td><b>Graph Transformation by defined Object Flow</b><br>
If selected, the graph transformation will be performed due to object flow of the currently selected rule sequence.
An object flow can be defined in an <i>Object Flow</i> dialog which is available  
from the <a href="RuleSequencesHelp.html"><i>Rule Sequence</i> dialog </a>.
The object flow is used to set the match (partially or total) of each rule.
</td></tr>

</table>
</blockquote>
<a href="#Content">back to Content</a>	


<p><a name="EditModePop-upMenu" id="EditModePop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Edit Mode & Operations</b>
<blockquote>
The most items of this context pop-up menu are already described
in <a href="#EditMenu">Edit</a> and
<a href="#ModeMenu">Mode</a> menus.
Some additional items are explained here.  
<table>
<tr><td> <b>Magic Edge Draw Support</b><br>
<i>Magic Edge</i> supports creation of an edge by foreseeing
the type of its target node. 
<i>Magic Edge</i> has got different appearance. 
It shows whether an outgoing edge of a (source) node
can be created (smiling green or quiet blue face) or not (sad red face). 
If the target node is not chosen by a user explicitly, 
it can be created automatically. 
This is the case when currently selected node type
is an appropriate type for the target node of this edge. 
When a type graph is defined and enabled, the type of a target node 
is defined, too. If the only one target node type is defined,
 the target node can be created automatically.
If there are several types for the target node,
 then the currently selected node type is taken into account.
When a type graph does not exist or disabled, 
any edge types between two nodes are allowed.
Furthermore, the target node can be created automatically, too.
<i>Magic Edge Draw Support</i> is optional and can be disabled.
It is enabled by default.<br>
Additionally, during editing graphs the name of the currently 
selected node type is shown by the tool tip text. 
For the currently selected edge type <i>edge:name</i> is used.
</td></tr>

<tr><td> <b>Synchron Move of Mapped Objects</b><br>
This action effects the rule editor only and  
 allows synchronized movement of mapped nodes and edges of a rule
with the aim to improve the readability of rules. 
<i>Synchron Move of Mapped Objects</i> is optional and can be enabled.
It is disabled by default.
</td></tr>

<tr><td> <b>Static Node Position</b><br>
This action effects the process of graph layouting. 
When it is selected, the positions of all already existing nodes remain 
unchanged during graph layouting. So only newly created nodes are placed
freely. This feature is useful during "step by step"
graph transformation. After each transformation step a newly
created node can be moved to an adequate position and it remains there
for the next steps.<br>
Furthermore, in combination with general transformation option 
<b>wait after step</b> (and maybe also with
<b>select new objects after step</b>) this setting can be useful
also during graph transformation in interpreting mode 
(started by "Transform -> Start"). 
</td></tr>

<tr><td> <b>Layout Graph</b><br>
The graph layouter behind this is a simplified form 
of the evolutionary layout algorithm for graph transformation sequence. 
When the current graph contains overlappings of nodes
this layouter can help to resolve these overlappings. 
</td></tr>

<tr><td> <b>Export JPEG</b><br>
Convert the current graph to an JPEG image and save it
into <i>fileName</i><b>.jpg</b>.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>	

<p><a name="OperationsPop-upMenu" id="OperationsPop-upMenu"></a></p>
&nbsp;&nbsp;&nbsp;<b>Operations</b> of Node and Edge
<blockquote>
This context pop-up menu contains graph object specific operations
which are valid only for the graph object the menu 
had been opened for.
Some items (Attributes, Copy, Delete, Straighten, Select, Select All, 
Map, Unmap) are already described
in menu <a href="#EditMenu">Edit</a>,
another items are explained here.  
<table>
<tr><td><b>Graph Layout > Static Position</b><br>
This operation is enabled for a node only
and can influence layout of the transformed graphs. 
In this case, the graph layouter should be enabled by selecting option
<b>perform during graph transformation</b> of the 
<a href="#Layouter">Layouter</a> options.
Setting static position allows to stop mobility of the
corresponding node.
If the corresponding node belongs to a type graph, the positions of
all instances of this node type become static.
The position of these nodes stay constant during graph evolution over time.
</td></tr>

<tr><td><b>Add Identic To > Rule RHS | NAC | PAC | General AC</b><br>
This operation is enabled for the current graph object inside of the LHS of a rule. 
The corresponding identic object is an object 
of the RHS | NAC | PAC | General AC graph of a rule.
As result of this operation, an identic object is created and mapped to its source object. 
</td></tr>
</table>

<table>
<tr><td> <b>Multiplicity</b><br>
This operation is enabled, if the current graph is a type graph.
(See <a href="#EditingTypeGraph">Editing Type Graph</a>)
</td></tr>

<tr><td> <b>Set Parent</b><br>
This operation is available for a type graph and a node only
and gives a possibility to enrich the type graph
with an inheritance relation between nodes.
(See <a href="#EditingTypeGraph">Editing Type Graph</a>)
</td></tr>

<tr><td> <b>Unset Parent</b><br>
This operation is available for a type graph and a node only
and allows to remove an inheritance relation between nodes.
(See <a href="#EditingTypeGraph">Editing Type Graph</a>)
</td></tr>

<tr><td> <b>Abstract</b><br>
This operation is available for a type graph and a node only.
An abstract node type may be used in rules, but
it is not allowed to create an instance node of an abstract type
inside of the host graph of a grammar.
(See <a href="#EditingTypeGraph">Editing Type Graph</a>)
</td></tr>

<tr><td> <b>Textual Comments</b><br>
This operation is available for nodes and edges of a type graph.
A simple text editor allows to put some comments 
for the specified type node or type edge.
</td></tr>
</table>
</blockquote>
<a href="#Content">back to Content</a>	
<p>


&nbsp;&nbsp;&nbsp;<b>Type Editor</b></p>

<blockquote>
<p><a name="NodeTypeEditor" id="NodeTypeEditor"></a>
&nbsp;&nbsp;&nbsp;<b>Node Type Editor</b> 
<p> 
This editor evailables to set the node type properties:
<b>name</b>, <b>color</b>, <b>shape</b>, <b>filled</b>.
<br>
Additionally, three more features of a node type can be set: 
<br> 
&nbsp;&nbsp;&nbsp;<b>Image</b> (.jpg, .gif) - it will be shown during graph transformation
<br>
&nbsp;&nbsp;&nbsp;<b>animated</b> - it means some kind of node animation  
during graph transformation. 
To get an animation effect of a node of an animated node type
an appropriate rule should be declared <b>animated</b>, too. 
Please note, this rule feature (see Rule Pop-up Menu) can be used with positive effect 
when a rule 
deletes and creates an outgoing edge from the same node  
to an other node. These source and target nodes should be preserved
by this rule. 
<br>
&nbsp;&nbsp;&nbsp;<b>Comment</b> - a short description of a node type.
</blockquote>

<blockquote> 
<p><a name="EdgeTypeEditor" id="EdgeTypeEditor"></a>
&nbsp;&nbsp;&nbsp;<b>Edge Type editor</b> 
<p> 
This editor evailables to set the edge type properties: 
<b>name</b>, <b>color</b>, line <b>style</b>, <b>bold</b>.
<br>
Additionally, <b>Comment</b> - a short description of an edge type can be added.

</blockquote>
<a href="#Content">back to Content</a>	
<p>
<p>
</TT>
</body>
</html>
